# WolkGatewayModule-Bluetooth
WolkAbout Gateway module for connecting bluetooth devices to WolkAbout Gateway.

Supported protocol(s):
* JSON_PROTOCOL

Installing from source
----------------------

This repository must be cloned from the command line using:
```sh
git clone --recurse-submodules https://github.com/Wolkabout/WolkGatewayModule-Bluetooth.git
```

Prerequisite
------
Following tools/libraries are required in order to build WolkAbout C++ connector

* cmake - version 3.5 or later
* autotools
* autoconf
* libtool
* m4
* zlib1g-dev
* python
* python pip
* conan
* bluez - version 5.5

With the exception of bluez the former can be installed on Debian based system from terminal by invoking

```sh
apt-get install autotools-dev autoconf libtool m4 zlib1g-dev cmake python python-pip && python -m pip install conan
```

To install bluez 5.5 with all it's dependencies you can run the install_bluez.sh script 
located in the /dependencies folder of this project.
After installing bluez it's recommended you reboot your system and check whether it was updated by invoking
```sh
bluetoothctl -v
```
It should display 5.50.

After the dependencies have been built, the Makefile build system is generated by invoking
`./configure`

Generated build system is located inside 'out' directory


WolkAbout C++ Connector library, and example are built from 'out' directory by invoking
`make` in terminal

The example should be run with two arguments - first one being the deviceConfiguration.json file and the second one
being the interval of the bluetooth scan in seconds(scan goes on/off alternately on the specified timeframe).
eg. 
```sh
./example deviceConfiguration.json 15
```
for a scan interval of 15 seconds.

The example will then scan for nearby bluetooth devices, detect if one of the devices that were specified in the .json file
by their key is present and if it is it will publish a '1' to the Wolkabout platform. If the device wasn't spotted in the timeframe
it will send a '0'. 

Example Usage
-------------
**Establishing connection with WolkAbout IoT platform:**
```cpp
wolkabout::Device device("DEVICE_KEY", "DEVICE_PASSWORD", {"ACTUATOR_REFERENCE_ONE", "ACTUATOR_REFERENCE_TWO"});

std::unique_ptr<wolkabout::Wolk> wolk =
  wolkabout::Wolk::newBuilder()
    .actuationHandler([](const std::string& deviceKey, const std::string& reference, const std::string& value) -> void {
        // TODO Invoke your code which activates actuator of specified device.

        std::cout << "Actuation request received - Key: " << deviceKey << " Reference: " << reference << " value: " << value << std::endl;
    })
    .actuatorStatusProvider([](const std::string& deviceKey, const std::string& reference) -> wolkabout::ActuatorStatus {
        // TODO Invoke code which reads the state of the actuator of specified device.

        if (deviceKey == "DEVICE_KEY" && reference == "SWITCH_ACTUATOR_REF") {
            return wolkabout::ActuatorStatus("true", wolkabout::ActuatorStatus::State::READY);

        return wolkabout::ActuatorStatus("", wolkabout::ActuatorStatus::State::READY);
    })
    .configurationHandler([](const std::map<std::string, std::string>& configuration) -> void {
        // TODO invoke code which sets device configuration
    })
    .configurationProvider([]() -> const std::map<std::string, std::string>& {
        // TODO invoke code which reads device configuration
        return std::map<std::string, std::string>();
    })
	.deviceStatusProvider([](const std::string& deviceKey) -> wolkabout::DeviceStatus {
        // TODO Invoke code which reads the status of specified device.

        if (deviceKey == "DEVICE_KEY")
        {
            return wolkabout::DeviceStatus::CONNECTED;
        }

        return wolkabout::DeviceStatus::OFFLINE;
    })
    .build();

    wolk->connect();
```

**Creating devices:**
```cpp

for (const auto& device : appConfiguration.getDevices())
    {
        wolk->addDevice(device);
    }
```

**Publishing sensor readings:**

The readings are added when the scan is done.
```cpp
 wolk->addSensorReading(key, sensor.getReference(), device_status[key]);
```

**Data publish strategy:**

Sensor readings, and alarms are pushed to WolkAbout IoT platform on demand by calling
```cpp
wolk->publish();

```
Publishing without providing device key publishes all available data,
whereas publishing with device key only data for the specified device is published

### Bluez
In this project we use the Bluez Bluetooth protocol stack for Linux.
All communication is done via GDbus, a software bus for inter-process communication and remote procedure call.

**Timer**
```cpp
guint timeout_id = g_timeout_add_seconds(time_in_seconds,       //time on which the callback is triggered
                                        timer_scan_publish,     //callback function
                                        (void*)wolk.get());     //void pointer to data passed on to the callback
```

**Switching the bluetooth adapter on/off**
```cpp
rc = adapter_set_property("Powered", g_variant_new("b", TRUE));
```

**Subscribing to the adapter property change**

```cpp
prop_changed = g_dbus_connection_signal_subscribe(con,
                        "org.bluez",
                        "org.freedesktop.DBus.Properties",
                        "PropertiesChanged",
                        NULL,
                        "org.bluez.Adapter1",
                        G_DBUS_SIGNAL_FLAGS_NONE,
                        signal_adapter_changed,
                        NULL,
                        NULL);
```
**Subscribing to the device added signal(ObjectManager)**
```cpp
iface_added = g_dbus_connection_signal_subscribe(con,
                            "org.bluez",
                            "org.freedesktop.DBus.ObjectManager",
                            "InterfacesAdded",
                            NULL,
                            NULL,
                            G_DBUS_SIGNAL_FLAGS_NONE,
                            device_appeared,
                            loop,
                            NULL);
```
**Subscribing to the device removed signal(ObjectManager)**
```cpp
iface_removed = g_dbus_connection_signal_subscribe(con,
                            "org.bluez",
                            "org.freedesktop.DBus.ObjectManager",
                            "InterfacesRemoved",
                            NULL,
                            NULL,
                            G_DBUS_SIGNAL_FLAGS_NONE,
                            device_disappeared,
                            loop,
                            NULL);
```

**Firmware Update**

WolkAbout C++ Connector provides mechanism for updating devices' firmware.
To enable firmware update one must provide implementation for wolkabout::FirmwareInstaller and wolkabout::FirmwareVersionProvider

See code snippet below on how to enable device firmware update for devices.

```c++

class CustomFirmwareInstaller: public wolkabout::FirmwareInstaller
{
public:
    void install(const std::string& deviceKey, const std::string& firmwareFile,
                 std::function<void(const std::string& deviceKey)> onSuccess,
                 std::function<void(const std::string& deviceKey)> onFail) override
    {
        // Mock install
        std::cout << "Updating firmware for device " << deviceKey << " with file " << firmwareFile << std::endl;

        onSuccess(deviceKey);
    }
};

class CustomFirmwareVersionProvider : public wolkabout::FirmwareVersionProvider
{
public:
    std::string getFirmwareVersion(const std::string& deviceKey)
    {
        // return firmware version for the device
        return "1.0";
    }
};

auto installer = std::make_shared<CustomFirmwareInstaller>();
auto provider = std::make_shared<CustomFirmwareVersionProvider>();

auto builder = wolkabout::Wolk::newBuilder()
    .actuationHandler([](const std::string& deviceKey, const std::string& reference, const std::string& value) -> void {
        // TODO Invoke your code which activates actuator of specified device.

        std::cout << "Actuation request received - Key: " << deviceKey << " Reference: " << reference << " value: " << value << std::endl;
    })
    .actuatorStatusProvider([](const std::string& deviceKey, const std::string& reference) -> wolkabout::ActuatorStatus {
        // TODO Invoke code which reads the state of the actuator of specified device.

        if (deviceKey == "DEVICE_KEY" && reference == "SWITCH_ACTUATOR_REF") {
            return wolkabout::ActuatorStatus("true", wolkabout::ActuatorStatus::State::READY);

        return wolkabout::ActuatorStatus("", wolkabout::ActuatorStatus::State::READY);
    })
    .configurationHandler([](const std::map<std::string, std::string>& configuration) -> void {
        // TODO invoke code which sets device configuration
    })
    .configurationProvider([]() -> const std::map<std::string, std::string>& {
        // TODO invoke code which reads device configuration
        return std::map<std::string, std::string>();
    })
    .deviceStatusProvider([](const std::string& deviceKey) -> wolkabout::DeviceStatus {
        // TODO Invoke code which reads the status of specified device.

        if (deviceKey == "DEVICE_KEY")
        {
            return wolkabout::DeviceStatus::CONNECTED;
        }

        return wolkabout::DeviceStatus::OFFLINE;
    })
    .withFirmwareUpdate(installer, provider)
    .build();
```
